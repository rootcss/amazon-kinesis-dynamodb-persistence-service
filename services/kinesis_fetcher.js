'use strict';

var KinesisStreamFetcher    = require('kinesis_stream_fetcher');
var utility                 = require('./utility.js');
var _                       = require('lodash');
var io                      = require('socket.io');
var config                  = require('config');

var SOCKET_IO; // socket created to emit dumps
var DYNAMODB_OBJ; // object for dynamodb class
// DYNAMO_INSERT_EVENTS flag is true by default. when set to false,
// the emitter will keep emitting, but data will be dumped into DDB
var DYNAMO_INSERT_EVENTS = config.get('Dynamo.insert_events');
// SHARDS_TO_REMOVE_REDUNDANCY array is being used to store the shards to
// ignore the first entry of every shard if it is already inserted into DD
var SHARDS_TO_REMOVE_REDUNDANCY = [];

class KinesisFetcherService {
    constructor(streamConfig, dynamo) {
        if(server) {
            this.server = server;
        } else {
            throw new Error('Server object is missing.');
        }
        this.streamConfig = streamConfig;
        this.socket = this.setSocket(this.server);
        if (dynamo) {
            DYNAMODB_OBJ = dynamo;
        } else {
            throw new Error('Dynamo object was not defined. Must be.');
        }
        if (DYNAMO_INSERT_EVENTS == true) {
            log.info("Events will be inserted into DynamoDB.")
        } else {
            log.warn("Config says not to insert into DynamoDB. Will keep emitting anyway.")
        }
    }

    setSocket(_server) {
        SOCKET_IO = io.listen(_server);
        log.info("Listening to socket.io server..");
    }

    streamEvents() {
        var ksf = new KinesisStreamFetcher(this.streamConfig);
        ksf.fetch();
        ksf.on('message', this.onMessage);
    }

    onMessage(data) {
        var dumper = prepareDataForDump(data);
        var current_shard = dumper.shardId;
        // if the shard already exists in the shard_array, keep inserting for that shard
        if (SHARDS_TO_REMOVE_REDUNDANCY.indexOf(current_shard) > -1) {
            if (DYNAMO_INSERT_EVENTS == true)
                DYNAMODB_OBJ.insert(dumper);
        } else {
            // if shard is not in the shard_array, check if that record already is in the DDB.
            // if already there, dont insert and push that shard into the shard_array.
            console.log("[*] Verifying first entry of shard '" + current_shard + "'..")
            console.log(dumper.eventId, dumper.shardId, dumper.sequenceNumber);
            DYNAMODB_OBJ.getCount(DYNAMODB_OBJ.model, dumper.eventId, null, null, function(err, data) {
                if (err) {
                    console.log(err);
                } else {
                    var count = Number(data[0]['Count']);
                    if (count == 0) {
                        console.log("This record was not dumped earlier. Inserting..");
                        if (DYNAMO_INSERT_EVENTS == true)
                            DYNAMODB_OBJ.insert(dumper);
                        SHARDS_TO_REMOVE_REDUNDANCY.push(dumper.shardId);
                    } else {
                        console.log("This record was already dumped. Skipping..");
                    }
                }
            });
        }
        SOCKET_IO.emit('datadump', dumper);
    }
}

// This function will prepare the payload to be dumped in DDB, in a required structure
// Also, it will omit some un-neccessary parameters and elements.
// That means, for different model, they will have separate similar functions.
var prepareDataForDump = function(data) {
    var dumper = {}
    if (data && data.payload && data.payload.records) {
        _.map(data.payload.records, function(record) {
            try {
                dumper['eventId'] = JSON.parse(new Buffer(record.Data.data).toString('utf8')).eventId;
                dumper['eventTimestamp'] = JSON.parse(new Buffer(record.Data.data).toString('utf8')).eventTimestamp.toString();
                dumper['eventName'] = JSON.parse(new Buffer(record.Data.data).toString('utf8')).eventName.toString();
                dumper['payload'] = JSON.stringify(JSON.parse(new Buffer(record.Data.data).toString('utf8')).payload);
            }
            catch(err) {
                // log.warn(err);
                console.log('[WARNING] Invalid Event metadata. Such inconsistencies may make the system in-accurate.');
            }
            dumper['sequenceNumber'] = record.SequenceNumber.toString('utf8');
        });
    }
    dumper['shardId'] = data.payload.shardId.toString('utf8')
    // shardId & sequenceNumber are generated by Kinesis, so we are not putting them in try-catch block.
    // Also they will be pushed into Redis, for next time retreival
    log.info("SeqNo: " + dumper['sequenceNumber']);
    return dumper;
};

module.exports = KinesisFetcherService;
